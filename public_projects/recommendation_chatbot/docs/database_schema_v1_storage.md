# 나비얌 챗봇 데이터 저장 전략 가이드

## 🧠 Gemini 분석 결과 요약
챗봇이 생성하는 데이터를 DB 저장 vs 메모리/캐시 저장으로 구분하여 성능과 데이터 지속성의 균형을 맞춤

---

## 🗄️ DB에 반드시 저장해야 하는 데이터

### 1. 대화 기록 및 NLU 정보 (conversations 테이블)
**DB 저장 필수 필드:**
- `input_text`, `response_text` - 대화 연속성 보장
- `extracted_intent`, `extracted_entities` - NLU 정확도 향상을 위한 학습 데이터
- `user_strategy`, `conversation_turn` - 개인화된 대화 흐름 구성
- `intent_confidence` - 모델 개선 및 디버깅용

**저장 이유:**
- 컨텍스트 기반 대화 지원
- 지속적인 학습을 위한 훈련 데이터 확보
- 사용자별 대화 패턴 분석

### 2. 사용자 상호작용 및 학습 데이터 (user_interactions 테이블)
**DB 저장 필수 필드:**
- `user_selection` - 실제 사용자 선택 (추천 모델 학습용)
- `food_preference_extracted` - 장기적 개인화
- `budget_pattern_extracted` - 예산 패턴 분석
- `companion_pattern_extracted` - 동반자 패턴
- `coupon_usage` - 쿠폰 전략 최적화

**저장 이유:**
- 머신러닝 모델 훈련 데이터
- 세션을 넘어서는 장기적 개인화
- 사용자 행동 패턴 분석

### 3. 추천 로그 (recommendations_log 테이블)
**DB 저장 필수 필드:**
- `recommendations` JSON - 추천 결과 및 이유 전체
- `confidence_score` - 추천 신뢰도
- `recommendation_method` - 사용된 추천 방식
- `total_discount_available` - 할인 정보
- 모든 요청 파라미터

**저장 이유:**
- A/B 테스트 수행
- 모델 성능 평가
- 추천 효과성 분석

### 4. 사용자 프로필 (user_profiles 테이블)
**DB 저장 필수 필드:**
- `preferred_categories` - 선호 카테고리
- `average_budget` - 평균 예산
- `good_influence_preference` - 착한가게 선호도
- `favorite_shops` - 즐겨찾기 가게
- `recent_orders` - 최근 주문 이력
- `coupon_preference` - 쿠폰 선호 패턴
- `monthly_stats` - 월별 사용 통계

**저장 이유:**
- 세션 간 지속되는 개인화
- 장기적 사용자 프로필 구축
- 맞춤형 추천 제공

---

## 💾 메모리/캐시에 보관 가능한 데이터

### 1. 실시간 계산 결과
**메모리 보관:**
- 현재 대화 컨텍스트 (최근 3-5개 대화)
- 단일 대화 중 임시 엔티티 추출 결과
- 실시간 추천 점수 계산
- 현재 세션의 상호작용 패턴

**이유:** 
- 빠르게 재계산 가능
- 일시적 데이터
- 장기 보관 가치 없음

### 2. 성능 모니터링 데이터
**캐시 전략:**
- 최근 1시간 성능 지표는 메모리 보관
- 15-30분마다 배치로 DB 저장
- 상세 분석용 시계열 DB 활용

**이유:**
- 고빈도 쓰기로 인한 성능 영향 방지
- 배치 처리로 처리량 향상

### 3. 파생/계산 필드
**캐시 보관:**
- `current_status` (영업 중/마감 상태)
- `days_until_expiry` (쿠폰 만료일 계산)
- `age_group`, `region_code` (기본 데이터에서 파생)
- 쿠폰 적용 후 실시간 잔액 계산

**이유:**
- 원본 데이터에서 즉시 계산 가능
- 지속적 저장 불필요

---

## 🔄 하이브리드 접근 방식

### 1. 스마트 캐싱 전략
```
메모리: 최근 24시간 대화
DB: 전체 대화 이력 (분석용)
캐시 TTL: 활성 사용자 4-6시간, 비활성 사용자 24시간
```

### 2. 성능 최적화
```
메모리: 실시간 추천 계산
DB: 최종 추천 결과 및 사용자 선택
Write-through: 중요 사용자 액션 (선택, 쿠폰 사용)
Write-behind: 분석 데이터 (성능 로그)
```

### 3. 데이터 생명주기 관리

#### 단기 (메모리/캐시 - 시간~일 단위):
- 현재 세션 컨텍스트
- 실시간 가용성 상태
- 임시 추천 점수
- 활성 대화 엔티티

#### 중기 (DB + 정기 정리 - 주~월 단위):
- 최근 대화 기록
- 성능 모니터링 데이터
- 임시 사용자 행동 패턴

#### 장기 (영구 DB 저장):
- 사용자 프로필 및 선호도
- 추천 효과성 이력
- 쿠폰 사용 패턴
- ML 모델을 위한 핵심 학습 데이터

---

## 📊 구현 권장사항

### 1. 쓰기 패턴
- **즉시 DB 저장:** 사용자 선택, 쿠폰 사용, 프로필 업데이트
- **배치 저장:** 성능 로그, 대화 요약
- **비동기 저장:** 상세 분석 데이터, 파생 통계

### 2. 읽기 패턴
- **캐시 우선:** 사용자 프로필, 최근 대화, 가게 상태
- **DB 직접:** 이력 분석, 종합 사용자 행동
- **하이브리드:** 실시간 추천 (캐시 + DB 쿼리)

### 3. 데이터 보존 정책
```sql
-- 보존 규칙 예시
conversations: 활성 사용자 6개월, 비활성 사용자 3개월
performance_logs: 상세 데이터 30일, 집계 데이터 1년
recommendations_log: 무기한 보존 (ML에 중요)
user_interactions: 무기한 보존 (핵심 학습 데이터)
```

---

## 🎯 핵심 포인트

1. **DB 저장 원칙**
   - 장기적 가치가 있는 데이터
   - 머신러닝 학습에 필요한 데이터
   - 사용자 경험 연속성을 위한 데이터

2. **메모리/캐시 활용 원칙**
   - 빠르게 재계산 가능한 데이터
   - 일시적이거나 세션 기반 데이터
   - 고빈도 접근이 필요한 데이터

3. **성능과 지속성의 균형**
   - 중요 데이터는 즉시 저장
   - 분석 데이터는 배치 처리
   - 캐시를 통한 응답 속도 최적화